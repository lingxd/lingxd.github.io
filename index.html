<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hokori.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="hentai">
<meta property="og:type" content="website">
<meta property="og:title" content="hokori">
<meta property="og:url" content="http://hokori.cn/index.html">
<meta property="og:site_name" content="hokori">
<meta property="og:description" content="hentai">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="hokori">
<meta property="article:tag" content="咸鱼">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hokori.cn/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>hokori</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hokori</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">浥轻尘i</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hokori.cn/2022/05/24/C++%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hokori">
      <meta itemprop="description" content="hentai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hokori">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/24/C++%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C++析构函数为什么要为虚函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-24 11:36:52" itemprop="dateCreated datePublished" datetime="2022-05-24T11:36:52+08:00">2022-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-析构函数为什么要为虚函数"><a href="#C-析构函数为什么要为虚函数" class="headerlink" title="C++析构函数为什么要为虚函数"></a><a href="https://hokori.cn/2019/10/09/C++%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0/">C++析构函数为什么要为虚函数</a></h1><p><strong>注：本文内容来源于zhice163博文，感谢作者的整理。</strong></p>
<p>1.为什么基类的析构函数是虚函数？</p>
<p>　　在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生。</p>
<p>　　下面转自网络：源地址 <a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_7c773cc50100y9hz.html">http://blog.sina.com.cn/s/blog_7c773cc50100y9hz.html</a></p>
<p>a.第一段代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClxBase</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClxBase</span>() &#123;&#125;;</span><br><span class="line">    ~<span class="built_in">ClxBase</span>() &#123;cout &lt;&lt; <span class="string">&quot;Output from the destructor of class ClxBase!&quot;</span> &lt;&lt; endl;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Do something in class ClxBase!&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClxDerived</span> : <span class="keyword">public</span> ClxBase&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClxDerived</span>() &#123;&#125;;</span><br><span class="line">    ~<span class="built_in">ClxDerived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Output from the destructor of class ClxDerived!&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Do something in class ClxDerived!&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="function"><span class="type">int</span>   <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">  ClxDerived *p =  <span class="keyword">new</span> ClxDerived;</span><br><span class="line">  p-&gt;<span class="built_in">DoSomething</span>();</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>　　运行结果：</p>
<p>　　Do something in class ClxDerived!            </p>
<p>　　Output from the destructor of class ClxDerived!</p>
<p>　　Output from the destructor of class ClxBase!  </p>
<p>　　这段代码中基类的析构函数不是虚函数,在main函数中用继承类的指针去操作继承类的成员,释放指针P的过程是:先释放继承类的资源,再释放基类资源. </p>
<p>　　b.第二段代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClxBase</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClxBase</span>() &#123;&#125;;</span><br><span class="line">    ~<span class="built_in">ClxBase</span>() &#123;cout &lt;&lt; <span class="string">&quot;Output from the destructor of class ClxBase!&quot;</span> &lt;&lt; endl;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Do something in class ClxBase!&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClxDerived</span> : <span class="keyword">public</span> ClxBase&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClxDerived</span>() &#123;&#125;;</span><br><span class="line">    ~<span class="built_in">ClxDerived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Output from the destructor of class ClxDerived!&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Do something in class ClxDerived!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="function"><span class="type">int</span>   <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">  ClxBase *p =  <span class="keyword">new</span> ClxDerived;</span><br><span class="line">  p-&gt;<span class="built_in">DoSomething</span>();</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>　　输出结果：</p>
<p>　　Do something in class ClxBase!<br>　　Output from the destructor of class ClxBase!</p>
<p><em>这段代码中基类的析构函数同样不是虚函数,不同的是在main函数中用基类的指针去操作继承类的成员,释放指针P的过程是:只是释放了基类的资源,而没有调用继承类的析构函数.调用dosomething()函数执行的也是基类定义的函数.</em></p>
<p><em>一般情况下,这样的删除只能够删除基类对象,而不能删除子类对象,形成了删除一半形象,造成内存泄漏.</em></p>
<p><em>在公有继承中,基类对派生类及其对象的操作,只能影响到那些从基类继承下来的成员.如果想要用基类对非继承成员进行操作,则要把基类的这个函数定义为虚函数.</em></p>
<p><em>析构函数自然也应该如此:如果它想析构子类中的重新定义或新的成员及对象,当然也应该声明为虚的.</em></p>
<p>　　c.第三段代码：
　　</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClxBase</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClxBase</span>() &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ClxBase</span>() &#123;cout &lt;&lt; <span class="string">&quot;Output from the destructor of class ClxBase!&quot;</span> &lt;&lt; endl;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Do something in class ClxBase!&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClxDerived</span> : <span class="keyword">public</span> ClxBase&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClxDerived</span>() &#123;&#125;;</span><br><span class="line">    ~<span class="built_in">ClxDerived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Output from the destructor of class ClxDerived!&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Do something in class ClxDerived!&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="type">int</span>   <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">  ClxBase *p =  <span class="keyword">new</span> ClxDerived;</span><br><span class="line">  p-&gt;<span class="built_in">DoSomething</span>();</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;  </span><br></pre></td></tr></table></figure>

<p>　　运行结果：</p>
<p>　　Do something in class ClxDerived!<br>　　Output from the destructor of class ClxDerived!<br>　　Output from the destructor of class ClxBase!</p>
<p><em>这段代码中基类的析构函数被定义为虚函数,在main函数中用基类的指针去操作继承类的成员,释放指针P的过程是:只是释放了继承类的资源,再调用基类的析构函数.调用dosomething()函数执行的也是继承类定义的函数。</em></p>
<p> <em>如果不需要基类对派生类及对象进行操作,则不能定义虚函数,因为这样会增加内存开销.当类里面有定义虚函数的时候,编译器会给类添加一个虚函数表,里面来存放虚函数指针,这样就会增加类的存储空间.所以,只有当一个类被用来作为基类的时候,才把析构函数写成虚函数。</em></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hokori.cn/2019/12/25/GOF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%C2%B7%E5%85%AB%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hokori">
      <meta itemprop="description" content="hentai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hokori">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/25/GOF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%C2%B7%E5%85%AB%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" class="post-title-link" itemprop="url">GOF设计模式·八大设计原则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-25 20:21:09" itemprop="dateCreated datePublished" datetime="2019-12-25T20:21:09+08:00">2019-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-24 11:36:52" itemprop="dateModified" datetime="2022-05-24T11:36:52+08:00">2022-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/C-11/" itemprop="url" rel="index"><span itemprop="name">C++11</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/C-11/GOF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">GOF设计模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="学习设计模式，为了是设计出更加优美，好维护，可复用，可拓展的优秀代码。"><a href="#学习设计模式，为了是设计出更加优美，好维护，可复用，可拓展的优秀代码。" class="headerlink" title="学习设计模式，为了是设计出更加优美，好维护，可复用，可拓展的优秀代码。"></a>学习设计模式，为了是设计出更加优美，好维护，可复用，可拓展的优秀代码。</h1><h2 id="八大设计原则"><a href="#八大设计原则" class="headerlink" title="八大设计原则"></a>八大设计原则</h2><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a><strong>依赖倒置原则</strong></h3><ul>
<li>高层模块不依赖底层模块，二者都应该依赖抽象;</li>
<li>抽象不依赖实现细节，实现细节应该依赖于抽象。</li>
</ul>
<blockquote>
<p>这一原则与下面的<strong>针对接口编程，而不是针对实现编程</strong>是一个道理，我们设计一个程序，我们应该先想好我们想要抽象什么，它应该具有什么样的能力，而不是先考虑怎么实现，这其中的具体方法，而最后在根据自己写的具体实现，从而汇总出最后的接口是什么。</p>
</blockquote>
<h3 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a><strong>开放封闭原则</strong></h3><ul>
<li>对拓展开放，对更改封闭;</li>
<li>类模块应该是可拓展的，但是不可修改的;</li>
<li>我们应该定义好接口之后就尽可能保证接口层的稳定。</li>
</ul>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a><strong>单一职责原则</strong></h3><ul>
<li>一个类应该仅有一个引起他变化的原因；</li>
<li>变化的方向隐含类的责任，若一个类中变化的部分过多，从而加剧了程序的维护难度，从而也许会修改这个类中的接口部分，也就违反了上面的第二原则。</li>
<li>其中变化（使用的具体实现等等），其中一定要明确这个部分中的具体目的。</li>
</ul>
<h3 id="Liskov替换原则"><a href="#Liskov替换原则" class="headerlink" title="Liskov替换原则"></a><strong>Liskov替换原则</strong></h3><ul>
<li>子类必须能够替换他们的基类。</li>
<li>继承表达类型的抽象。</li>
<li>假如子类不可以替换他们的基类那么大部分的设计模式都无从谈起。</li>
</ul>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a><strong>接口隔离原则</strong></h3><ul>
<li>不应该“强迫”客户程序依赖他们不用的方法。</li>
<li>接口应该小而完备。</li>
<li>设计对象的时候我们应该明确的知道这个对象应该要包含什么功能，然后做出相应的接口，其余一些客户不用的方法全部隐藏起来。</li>
</ul>
<h3 id="优先使用对象组合，而不是类继承"><a href="#优先使用对象组合，而不是类继承" class="headerlink" title="优先使用对象组合，而不是类继承"></a><strong>优先使用对象组合，而不是类继承</strong></h3><ul>
<li>白箱复用：将父类的全部内容暴露给子类。</li>
<li>黑箱复用：只暴露想暴露的部分，其余的内容对其类不可见。<ul>
<li><strong>类继承</strong>通常称为<em>白箱复用</em><br><strong>对象组合</strong>通常被称为<em>黑箱复用</em></li>
<li>继承在某种程度上破坏了封装性,子类父类耦合度高</li>
<li>对象组合则只要求被组合的对象具有良好的定义的接口。</li>
</ul>
</li>
</ul>
<h3 id="封装变化点"><a href="#封装变化点" class="headerlink" title="封装变化点"></a><strong>封装变化点</strong></h3><ul>
<li>使用封装来创建对象之间的分界层，让设计者可以在变化的另一侧修改，而不会对另一侧产生不影响，从而达到层次间的松耦合。</li>
</ul>
<h3 id="针对接口编程，而不是针对实现编程"><a href="#针对接口编程，而不是针对实现编程" class="headerlink" title="针对接口编程，而不是针对实现编程"></a><strong>针对接口编程，而不是针对实现编程</strong></h3><ul>
<li>不将变量类型声明为某个特定类型的具体类，而是声明为某个接口。</li>
<li>客户程序无需知道对象的具体类型，只需要知道对象所具有的接口。</li>
<li>减少系统中各部分的依赖关系，从而实现”<strong>高内聚</strong>，<strong>松耦合</strong>“的类型设计方案。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hokori.cn/2019/12/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hokori">
      <meta itemprop="description" content="hentai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hokori">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" class="post-title-link" itemprop="url">面向对象设计原则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-25 20:21:09" itemprop="dateCreated datePublished" datetime="2019-12-25T20:21:09+08:00">2019-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-24 11:36:52" itemprop="dateModified" datetime="2022-05-24T11:36:52+08:00">2022-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">面向对象</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="依赖倒置原则（DIP）："><a href="#依赖倒置原则（DIP）：" class="headerlink" title="依赖倒置原则（DIP）："></a>依赖倒置原则（DIP）：</h3><ul>
<li>高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）。</li>
<li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。</li>
</ul>
<h3 id="开放封闭原则（OCP）"><a href="#开放封闭原则（OCP）" class="headerlink" title="开放封闭原则（OCP）"></a>开放封闭原则（OCP）</h3><ul>
<li>对扩展开放，对更改封闭</li>
<li>类模板应该是可扩展的，但是不可修改</li>
</ul>
<h3 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h3><ul>
<li>一个类应该仅有一个引起它变化的原因</li>
<li>变化的方向隐含着类的责任</li>
</ul>
<h3 id="Liskov替换原则（LSP）"><a href="#Liskov替换原则（LSP）" class="headerlink" title="Liskov替换原则（LSP）"></a>Liskov替换原则（LSP）</h3><ul>
<li>子类必须能够替换他们的基类（IS-A）</li>
<li>继承表达类型抽象</li>
</ul>
<h3 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h3><ul>
<li>不应该强迫客户依赖他们不用的方法</li>
<li>接口应该小而完备</li>
</ul>
<h3 id="优先使用对象组合，而不是类继承"><a href="#优先使用对象组合，而不是类继承" class="headerlink" title="优先使用对象组合，而不是类继承"></a>优先使用对象组合，而不是类继承</h3><ul>
<li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”</li>
<li>继承在某种程度上破坏了封装性，子类父类耦合度高</li>
<li>而对象组合只要求被组合的对象具有良好定义的接口，耦合度低</li>
</ul>
<h3 id="封装变化点"><a href="#封装变化点" class="headerlink" title="封装变化点"></a>封装变化点</h3><ul>
<li>使用封装来创建对象之间的分界层，让设计者可以在分界层一侧进行修改，而不会对另一侧产生不良影响，从而实现层次间的松耦合</li>
</ul>
<h3 id="针对接口编程，而不是针对实现编程"><a href="#针对接口编程，而不是针对实现编程" class="headerlink" title="针对接口编程，而不是针对实现编程"></a>针对接口编程，而不是针对实现编程</h3><ul>
<li>不将变量类型声明为某个特定的具体类，而是声明为某个接口</li>
<li>客户程序无需获取对象的具体类型，只需要知道对象所具有具有的接口</li>
<li>减少系统中各部分的依赖关系，从而实现“高内聚，松耦合”的类型设计方案</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hokori.cn/2019/12/04/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B(6)%E3%80%90%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hokori">
      <meta itemprop="description" content="hentai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hokori">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/04/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B(6)%E3%80%90%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E3%80%91/" class="post-title-link" itemprop="url">C++11多线程(6)【条件变量(Condition Variable)】</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-04 20:21:09" itemprop="dateCreated datePublished" datetime="2019-12-04T20:21:09+08:00">2019-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-24 11:36:52" itemprop="dateModified" datetime="2022-05-24T11:36:52+08:00">2022-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/C-11/" itemprop="url" rel="index"><span itemprop="name">C++11</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/C-11/%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>互斥锁<code>std::mutex</code>是一种最常见的线程间同步的手段，但是在有些情况下不太高效。</p>
<p>假设想实现一个简单的消费者生产者模型，一个线程往队列中放入数据，一个线程往队列中取数据，取数据前需要判断一下队列中确实有数据，由于这个队列是线程间共享的，所以，需要使用互斥锁进行保护，一个线程在往队列添加数据的时候，另一个线程不能取，反之亦然。用互斥锁实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">std::mutex mu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mu)</span></span>;</span><br><span class="line">        q.<span class="built_in">push_front</span>(count);</span><br><span class="line">        locker.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( data != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mu)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            data = q.<span class="built_in">back</span>();</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">            locker.<span class="built_in">unlock</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;t2 got a value from t1: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            locker.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(function_1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(function_2)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//t2 got a value from t1: 10</span></span><br><span class="line"><span class="comment">//t2 got a value from t1: 9</span></span><br><span class="line"><span class="comment">//t2 got a value from t1: 8</span></span><br><span class="line"><span class="comment">//t2 got a value from t1: 7</span></span><br><span class="line"><span class="comment">//t2 got a value from t1: 6</span></span><br><span class="line"><span class="comment">//t2 got a value from t1: 5</span></span><br><span class="line"><span class="comment">//t2 got a value from t1: 4</span></span><br><span class="line"><span class="comment">//t2 got a value from t1: 3</span></span><br><span class="line"><span class="comment">//t2 got a value from t1: 2</span></span><br><span class="line"><span class="comment">//t2 got a value from t1: 1</span></span><br></pre></td></tr></table></figure>

<p>可以看到，互斥锁其实可以完成这个任务，但是却存在着性能问题。</p>
<p>首先，<code>function_1</code>函数是生产者，在生产过程中，<code>std::this_thread::sleep_for(std::chrono::seconds(1));</code>表示延时<code>1s</code>，所以这个生产的过程是很慢的；<code>function_2</code>函数是消费者，存在着一个<code>while</code>循环，只有在接收到表示结束的数据的时候，才会停止，每次循环内部，都是先加锁，判断队列不空，然后就取出一个数，最后解锁。所以说，在<code>1s</code>内，做了很多无用功！这样的话，CPU占用率会很高，可能达到100%（单核）。如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4427263-4ac3dca6030dd96f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/616/format/webp" alt="img"></p>
<p>CPU占用率.png</p>
<p>解决办法之一是给消费者也加一个小延时，如果一次判断后，发现队列是空的，就惩罚一下自己，延时<code>500ms</code>，这样可以减小CPU的占用率。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( data != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mu)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            data = q.<span class="built_in">back</span>();</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">            locker.<span class="built_in">unlock</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;t2 got a value from t1: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            locker.<span class="built_in">unlock</span>();</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4427263-236c78f4efd1ef35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/630/format/webp" alt="img"></p>
<p>使用延时的CPU占用率.png</p>
<p>然后困难之处在于，如何确定这个延时时间呢，假如生产者生产的很快，消费者却延时<code>500ms</code>，也不是很好，如果生产者生产的更慢，那么消费者延时<code>500ms</code>，还是不必要的占用了CPU。</p>
<p>这就引出了条件变量（condition variable）,<code>c++11</code>中提供了<code>#include </code>头文件，其中的<code>std::condition_variable</code>可以和<code>std::mutex</code>结合一起使用，其中有两个重要的接口，<code>notify_one()</code>和<code>wait()</code>，<code>wait()</code>可以让线程陷入<strong>休眠状态</strong>，在消费者生产者模型中，如果生产者发现队列中没有东西，就可以让自己休眠，但是不能一直不干活啊，<code>notify_one()</code>就是<strong>唤醒</strong>处于<code>wait</code>中的<strong>其中一个条件变量</strong>（可能当时有很多条件变量都处于<code>wait</code>状态）。那什么时刻使用<code>notify_one()</code>比较好呢，当然是在生产者往队列中放数据的时候了，队列中有数据，就可以赶紧叫醒等待中的线程起来干活了。</p>
<p>使用条件变量修改后如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">std::mutex mu;</span><br><span class="line">std::condition_variable cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mu)</span></span>;</span><br><span class="line">        q.<span class="built_in">push_front</span>(count);</span><br><span class="line">        locker.<span class="built_in">unlock</span>();</span><br><span class="line">        cond.<span class="built_in">notify_one</span>();  <span class="comment">// Notify one waiting thread, if there is one.</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( data != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mu)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">empty</span>())</span><br><span class="line">            cond.<span class="built_in">wait</span>(locker); <span class="comment">// Unlock mu and wait to be notified</span></span><br><span class="line">        data = q.<span class="built_in">back</span>();</span><br><span class="line">        q.<span class="built_in">pop_back</span>();</span><br><span class="line">        locker.<span class="built_in">unlock</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;t2 got a value from t1: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(function_1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(function_2)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时CPU的占用率也很低。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4427263-236c78f4efd1ef35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/630/format/webp" alt="img"></p>
<p>使用条件变量时的CPU占用率.png</p>
<p>上面的代码有三个注意事项：</p>
<ol>
<li>在<code>function_2</code>中，在判断队列是否为空的时候，使用的是<code>while(q.empty())</code>，而不是<code>if(q.empty())</code>，这是因为<code>wait()</code>从阻塞到返回，不一定就是由于<code>notify_one()</code>函数造成的，还有可能由于系统的不确定原因唤醒（可能和条件变量的实现机制有关），这个的时机和频率都是不确定的，被称作<strong>伪唤醒</strong>，如果在错误的时候被唤醒了，执行后面的语句就会错误，所以需要再次判断队列是否为空，如果还是为空，就继续<code>wait()</code>阻塞。</li>
<li>在管理互斥锁的时候，使用的是<code>std::unique_lock</code>而不是<code>std::lock_guard</code>，而且事实上也不能使用<code>std::lock_guard</code>，这需要先解释下<code>wait()</code>函数所做的事情。可以看到，在<code>wait()</code>函数之前，使用互斥锁保护了，如果<code>wait</code>的时候什么都没做，岂不是一直持有互斥锁？那生产者也会一直卡住，不能够将数据放入队列中了。所以，**<code>wait()</code>函数会先调用互斥锁的<code>unlock()</code>函数，然后再将自己睡眠，在被唤醒后，又会继续持有锁，保护后面的队列操作。**而<code>lock_guard</code>没有<code>lock</code>和<code>unlock</code>接口，而<code>unique_lock</code>提供了。这就是必须使用<code>unique_lock</code>的原因。</li>
<li>使用细粒度锁，尽量减小锁的范围，在<code>notify_one()</code>的时候，不需要处于互斥锁的保护范围内，所以在唤醒条件变量之前可以将锁<code>unlock()</code>。</li>
</ol>
<p>还可以将<code>cond.wait(locker);</code>换一种写法，<code>wait()</code>的第二个参数可以传入一个函数表示检查条件，这里使用<code>lambda</code>函数最为简单，如果这个函数返回的是<code>true</code>，<code>wait()</code>函数不会阻塞会直接返回，如果这个函数返回的是<code>false</code>，<code>wait()</code>函数就会阻塞着等待唤醒，如果被伪唤醒，会继续判断函数返回值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( data != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mu)</span></span>;</span><br><span class="line">        cond.<span class="built_in">wait</span>(locker, []()&#123; <span class="keyword">return</span> !q.<span class="built_in">empty</span>();&#125; );  <span class="comment">// Unlock mu and wait to be notified</span></span><br><span class="line">        data = q.<span class="built_in">back</span>();</span><br><span class="line">        q.<span class="built_in">pop_back</span>();</span><br><span class="line">        locker.<span class="built_in">unlock</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;t2 got a value from t1: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了<code>notify_one()</code>函数，<code>c++</code>还提供了<code>notify_all()</code>函数，可以同时唤醒所有处于<code>wait</code>状态的条件变量。</p>
<p>作者：<a target="_blank" rel="noopener" href="https://www.jianshu.com/u/a549acfa2f33">StormZhu</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hokori.cn/2019/12/03/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B(5)%E3%80%90%E4%BA%92%E6%96%A5%E9%94%81%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hokori">
      <meta itemprop="description" content="hentai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hokori">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/03/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B(5)%E3%80%90%E4%BA%92%E6%96%A5%E9%94%81%E3%80%91/" class="post-title-link" itemprop="url">C++11多线程(5)【互斥锁(unique_lock)】</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-03 20:21:09" itemprop="dateCreated datePublished" datetime="2019-12-03T20:21:09+08:00">2019-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-24 11:36:52" itemprop="dateModified" datetime="2022-05-24T11:36:52+08:00">2022-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/C-11/" itemprop="url" rel="index"><span itemprop="name">C++11</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/C-11/%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>互斥锁保证了线程间的同步，但是却将并行操作变成了串行操作，这对性能有很大的影响，所以我们要尽可能的<strong>减小锁定的区域</strong>，也就是使用<strong>细粒度锁</strong>。</p>
<p>这一点<code>lock_guard</code>做的不好，不够灵活，<code>lock_guard</code>只能保证在析构的时候执行解锁操作，<code>lock_guard</code>本身并没有提供加锁和解锁的接口，但是有些时候会有这种需求。看下面的例子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogFile</span> &#123;</span><br><span class="line">    std::mutex _mu;</span><br><span class="line">    ofstream f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LogFile</span>() &#123;</span><br><span class="line">        f.<span class="built_in">open</span>(<span class="string">&quot;log.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">LogFile</span>() &#123;</span><br><span class="line">        f.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shared_print</span><span class="params">(string msg, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(_mu)</span></span>;</span><br><span class="line">            <span class="comment">//do something 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//do something 2</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(_mu)</span></span>;</span><br><span class="line">            <span class="comment">// do something 3</span></span><br><span class="line">            f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，一个函数内部有两段代码需要进行保护，这个时候使用<code>lock_guard</code>就需要创建两个局部对象来管理同一个互斥锁（其实也可以只创建一个，但是锁的力度太大，效率不行），修改方法是使用<code>unique_lock</code>。它提供了<code>lock()</code>和<code>unlock()</code>接口，能记录现在处于上锁还是没上锁状态，在析构的时候，会根据当前状态来决定是否要进行解锁（<code>lock_guard</code>就一定会解锁）。上面的代码修改如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogFile</span> &#123;</span><br><span class="line">    std::mutex _mu;</span><br><span class="line">    ofstream f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LogFile</span>() &#123;</span><br><span class="line">        f.<span class="built_in">open</span>(<span class="string">&quot;log.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">LogFile</span>() &#123;</span><br><span class="line">        f.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shared_print</span><span class="params">(string msg, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(_mu)</span></span>;</span><br><span class="line">        <span class="comment">//do something 1</span></span><br><span class="line">        guard.<span class="built_in">unlock</span>(); <span class="comment">//临时解锁</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//do something 2</span></span><br><span class="line"></span><br><span class="line">        guard.<span class="built_in">lock</span>(); <span class="comment">//继续上锁</span></span><br><span class="line">        <span class="comment">// do something 3</span></span><br><span class="line">        f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 结束时析构guard会临时解锁</span></span><br><span class="line">        <span class="comment">// 这句话可要可不要，不写，析构的时候也会自动执行</span></span><br><span class="line">        <span class="comment">// guard.ulock();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码可以看到，在无需加锁的操作时，可以先临时释放锁，然后需要继续保护的时候，可以继续上锁，这样就无需重复的实例化<code>lock_guard</code>对象，还能减少锁的区域。同样，可以使用<code>std::defer_lock</code>设置初始化的时候不进行默认的上锁操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shared_print</span><span class="params">(string msg, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(_mu, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="comment">//do something 1</span></span><br><span class="line"></span><br><span class="line">    guard.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">// do something protected</span></span><br><span class="line">    guard.<span class="built_in">unlock</span>(); <span class="comment">//临时解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//do something 2</span></span><br><span class="line"></span><br><span class="line">    guard.<span class="built_in">lock</span>(); <span class="comment">//继续上锁</span></span><br><span class="line">    <span class="comment">// do something 3</span></span><br><span class="line">    f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 结束时析构guard会临时解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样使用起来就比<code>lock_guard</code>更加灵活！然后这也是有代价的，因为它内部需要维护锁的状态，所以效率要比<code>lock_guard</code>低一点，在<code>lock_guard</code>能解决问题的时候，就是用<code>lock_guard</code>，反之，使用<code>unique_lock</code>。</p>
<p>后面在学习条件变量的时候，还会有<code>unique_lock</code>的用武之地。</p>
<p>另外，请注意，<code>unique_lock</code>和<code>lock_guard</code>都不能复制，<code>lock_guard</code>不能移动，但是<code>unique_lock</code>可以！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unique_lock 可以移动，不能复制</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(_mu)</span></span>;</span><br><span class="line">std::unique_lock&lt;std::mutex&gt; guard2 = guard1;  <span class="comment">// error</span></span><br><span class="line">std::unique_lock&lt;std::mutex&gt; guard2 = std::<span class="built_in">move</span>(guard1); <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lock_guard 不能移动，不能复制</span></span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(_mu)</span></span>;</span><br><span class="line">std::lock_guard&lt;std::mutex&gt; guard2 = guard1;  <span class="comment">// error</span></span><br><span class="line">std::lock_guard&lt;std::mutex&gt; guard2 = std::<span class="built_in">move</span>(guard1); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>作者：<a target="_blank" rel="noopener" href="https://www.jianshu.com/u/a549acfa2f33">StormZhu</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hokori.cn/2019/12/02/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)%E3%80%90%E6%AD%BB%E9%94%81%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hokori">
      <meta itemprop="description" content="hentai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hokori">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/02/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)%E3%80%90%E6%AD%BB%E9%94%81%E3%80%91/" class="post-title-link" itemprop="url">C++11多线程(4)【死锁(Dead Lock)】</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-02 18:21:09" itemprop="dateCreated datePublished" datetime="2019-12-02T18:21:09+08:00">2019-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-24 11:36:52" itemprop="dateModified" datetime="2022-05-24T11:36:52+08:00">2022-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/C-11/" itemprop="url" rel="index"><span itemprop="name">C++11</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/C-11/%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>如果你将某个<code>mutex</code>上锁了，却一直不释放，另一个线程访问该锁保护的资源的时候，就会发生死锁，这种情况下使用<code>lock_guard</code>可以保证析构的时候能够释放锁，然而，当一个操作需要使用两个互斥元的时候，仅仅使用<code>lock_guard</code>并不能保证不会发生死锁，如下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogFile</span> &#123;</span><br><span class="line">    std::mutex _mu;</span><br><span class="line">    std::mutex _mu2;</span><br><span class="line">    ofstream f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LogFile</span>() &#123;</span><br><span class="line">        f.<span class="built_in">open</span>(<span class="string">&quot;log.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">LogFile</span>() &#123;</span><br><span class="line">        f.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shared_print</span><span class="params">(string msg, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(_mu)</span></span>;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard2</span><span class="params">(_mu2)</span></span>;</span><br><span class="line">        f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shared_print2</span><span class="params">(string msg, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(_mu2)</span></span>;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard2</span><span class="params">(_mu)</span></span>;</span><br><span class="line">        f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_1</span><span class="params">(LogFile&amp; log)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&gt;<span class="number">-100</span>; i--)</span><br><span class="line">        log.<span class="built_in">shared_print2</span>(<span class="built_in">string</span>(<span class="string">&quot;From t1: &quot;</span>), i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogFile log;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(function_1, std::ref(log))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">        log.<span class="built_in">shared_print</span>(<span class="built_in">string</span>(<span class="string">&quot;From main: &quot;</span>), i);</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后，你会发现程序会卡住，这就是发生死锁了。程序运行可能会发生类似下面的情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread A              Thread B</span><br><span class="line">_mu.<span class="built_in">lock</span>()          _mu2.<span class="built_in">lock</span>()</span><br><span class="line">   <span class="comment">//死锁               //死锁</span></span><br><span class="line">_mu2.<span class="built_in">lock</span>()         _mu.<span class="built_in">lock</span>()</span><br></pre></td></tr></table></figure>

<p>解决办法有很多：</p>
<ol>
<li><p>可以比较<code>mutex</code>的地址，每次都先锁地址小的，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&amp;_mu &lt; &amp;_mu2)&#123;</span><br><span class="line">    _mu.<span class="built_in">lock</span>();</span><br><span class="line">    _mu2.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    _mu2.<span class="built_in">lock</span>();</span><br><span class="line">    _mu.<span class="built_in">lock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用层次锁，将互斥锁包装一下，给锁定义一个层次的属性，每次按层次由高到低的顺序上锁。</p>
</li>
</ol>
<p>这两种办法其实都是严格规定上锁顺序，只不过实现方式不同。</p>
<p><code>c++</code>标准库中提供了<code>std::lock()</code>函数，能够保证将多个互斥锁同时上锁，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">lock</span>(_mu, _mu2);</span><br></pre></td></tr></table></figure>

<p>同时，<code>lock_guard</code>也需要做修改，因为互斥锁已经被上锁了，那么<code>lock_guard</code>构造的时候不应该上锁，只是需要在析构的时候释放锁就行了，使用<code>std::adopt_lock</code>表示无需上锁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(_mu2, std::adopt_lock)</span></span>;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard2</span><span class="params">(_mu, std::adopt_lock)</span></span>;</span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogFile</span> &#123;</span><br><span class="line">    std::mutex _mu;</span><br><span class="line">    std::mutex _mu2;</span><br><span class="line">    ofstream f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LogFile</span>() &#123;</span><br><span class="line">        f.<span class="built_in">open</span>(<span class="string">&quot;log.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">LogFile</span>() &#123;</span><br><span class="line">        f.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shared_print</span><span class="params">(string msg, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">lock</span>(_mu, _mu2);</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(_mu, std::adopt_lock)</span></span>;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard2</span><span class="params">(_mu2, std::adopt_lock)</span></span>;</span><br><span class="line">        f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shared_print2</span><span class="params">(string msg, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">lock</span>(_mu, _mu2);</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(_mu2, std::adopt_lock)</span></span>;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard2</span><span class="params">(_mu, std::adopt_lock)</span></span>;</span><br><span class="line">        f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_1</span><span class="params">(LogFile&amp; log)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&gt;<span class="number">-100</span>; i--)</span><br><span class="line">        log.<span class="built_in">shared_print2</span>(<span class="built_in">string</span>(<span class="string">&quot;From t1: &quot;</span>), i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogFile log;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(function_1, std::ref(log))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">        log.<span class="built_in">shared_print</span>(<span class="built_in">string</span>(<span class="string">&quot;From main: &quot;</span>), i);</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下，对于避免死锁，有以下几点建议：</p>
<ol>
<li><p>建议尽量同时只对一个互斥锁上锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(_mu2)</span></span>;</span><br><span class="line"> <span class="comment">//do something</span></span><br><span class="line">    f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard2</span><span class="params">(_mu)</span></span>;</span><br><span class="line"> cout &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在互斥锁保护的区域使用用户自定义的代码，因为用户的代码可能操作了其他的互斥锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(_mu2)</span></span>;</span><br><span class="line"> <span class="built_in">user_function</span>(); <span class="comment">// never do this!!!</span></span><br><span class="line">    f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想同时对多个互斥锁上锁，要使用<code>std::lock()</code>。</p>
</li>
<li><p>给锁定义顺序（使用层次锁，或者比较地址等），每次以同样的顺序进行上锁。详细介绍可看<a target="_blank" rel="noopener" href="https://book.douban.com/subject/26386925/">C++并发编程实战</a>。</p>
</li>
</ol>
<p>作者：<a target="_blank" rel="noopener" href="https://www.jianshu.com/u/a549acfa2f33">StormZhu</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hokori.cn/2019/12/01/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B(3)%E3%80%90%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E4%B8%8E%E4%BA%92%E6%96%A5%E5%AF%B9%E8%B1%A1%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hokori">
      <meta itemprop="description" content="hentai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hokori">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/01/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B(3)%E3%80%90%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E4%B8%8E%E4%BA%92%E6%96%A5%E5%AF%B9%E8%B1%A1%E3%80%91/" class="post-title-link" itemprop="url">C++11多线程(3)【数据竞争与互斥对象】</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-01 18:21:09" itemprop="dateCreated datePublished" datetime="2019-12-01T18:21:09+08:00">2019-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-24 11:36:52" itemprop="dateModified" datetime="2022-05-24T11:36:52+08:00">2022-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/C-11/" itemprop="url" rel="index"><span itemprop="name">C++11</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/C-11/%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>并发代码中最常见的错误之一就是**竞争条件(race condition)<strong>。而其中最常见的就是</strong>数据竞争(data race)**，从整体上来看，所有线程之间共享数据的问题，都是修改数据导致的，如果所有的共享数据都是只读的，就不会发生问题。但是这是不可能的，大部分共享数据都是要被修改的。</p>
<p>而<code>c++</code>中常见的<code>cout</code>就是一个共享资源，如果在多个线程同时执行<code>cout</code>，你会发发现很奇怪的问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数 无参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&gt;<span class="number">-100</span>; i--)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;From t1: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(function_1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;From main: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你有很大的几率发现打印会出现类似于<code>From t1: From main: 64</code>这样奇怪的打印结果。<code>cout</code>是基于流的，会先将你要打印的内容放入缓冲区，可能刚刚一个线程刚刚放入<code>From t1:</code>，另一个线程就执行了，导致输出变乱。而<code>c</code>语言中的<code>printf</code>不会发生这个问题。</p>
<h2 id="使用互斥元保护共享数据"><a href="#使用互斥元保护共享数据" class="headerlink" title="使用互斥元保护共享数据"></a>使用互斥元保护共享数据</h2><p>解决办法就是要对<code>cout</code>这个共享资源进行保护。在<code>c++</code>中，可以使用互斥锁<code>std::mutex</code>进行资源保护，头文件是<code>#include </code>，共有两种操作：**锁定(lock)<strong>与</strong>解锁(unlock)**。将<code>cout</code>重新封装成一个线程安全的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::mutex mu;</span><br><span class="line"><span class="comment">// 使用锁保护</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shared_print</span><span class="params">(string msg, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    mu.<span class="built_in">lock</span>(); <span class="comment">// 上锁</span></span><br><span class="line">    cout &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    mu.<span class="built_in">unlock</span>(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&gt;<span class="number">-100</span>; i--)</span><br><span class="line">        <span class="built_in">shared_print</span>(<span class="built_in">string</span>(<span class="string">&quot;From t1: &quot;</span>), i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(function_1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">        <span class="built_in">shared_print</span>(<span class="built_in">string</span>(<span class="string">&quot;From main: &quot;</span>), i);</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改完之后，运行可以发现打印没有问题了。但是还有一个隐藏着的问题，如果<code>mu.lock()</code>和<code>mu.unlock()</code>之间的语句发生了异常，会发生什么？<code>unlock()</code>语句没有机会执行！导致导致<code>mu</code>一直处于锁着的状态，其他使用<code>shared_print()</code>函数的线程就会阻塞。</p>
<p>解决这个问题也很简单，使用<code>c++</code>中常见的<code>RAII</code>技术，即**获取资源即初始化(Resource Acquisition Is Initialization)**技术，这是<code>c++</code>中管理资源的常用方式。简单的说就是在类的构造函数中创建资源，在析构函数中释放资源，因为就算发生了异常，<code>c++</code>也能保证类的析构函数能够执行。我们不需要自己写个类包装<code>mutex</code>，<code>c++</code>库已经提供了<code>std::lock_guard</code>类模板，使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shared_print</span><span class="params">(string msg, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造的时候帮忙上锁，析构的时候释放锁</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mu)</span></span>;</span><br><span class="line">    <span class="comment">//mu.lock(); // 上锁</span></span><br><span class="line">    cout &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//mu.unlock(); // 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以实现自己的<code>std::lock_guard</code>，类似这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MutexLockGuard</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MutexLockGuard</span><span class="params">(std::mutex&amp; mutex)</span></span></span><br><span class="line"><span class="function">    : mutex_(mutex)</span></span><br><span class="line"><span class="function">  &#123;</span></span><br><span class="line">    mutex_.<span class="built_in">lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">MutexLockGuard</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.<span class="built_in">unlock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::mutex&amp; mutex_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="为保护共享数据精心组织代码"><a href="#为保护共享数据精心组织代码" class="headerlink" title="为保护共享数据精心组织代码"></a>为保护共享数据精心组织代码</h2><p>上面的<code>std::mutex</code>互斥元是个全局变量，他是为<code>shared_print()</code>准备的，这个时候，我们最好将他们绑定在一起，比如说，可以封装成一个类。由于<code>cout</code>是个全局共享的变量，没法完全封装，就算你封装了，外面还是能够使用<code>cout</code>，并且不用通过锁。下面使用文件流举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::mutex mu;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogFile</span> &#123;</span><br><span class="line">    std::mutex m_mutex;</span><br><span class="line">    ofstream f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LogFile</span>() &#123;</span><br><span class="line">        f.<span class="built_in">open</span>(<span class="string">&quot;log.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">LogFile</span>() &#123;</span><br><span class="line">        f.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shared_print</span><span class="params">(string msg, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_1</span><span class="params">(LogFile&amp; log)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&gt;<span class="number">-100</span>; i--)</span><br><span class="line">        log.<span class="built_in">shared_print</span>(<span class="built_in">string</span>(<span class="string">&quot;From t1: &quot;</span>), i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogFile log;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(function_1, std::ref(log))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">        log.<span class="built_in">shared_print</span>(<span class="built_in">string</span>(<span class="string">&quot;From main: &quot;</span>), i);</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>LogFile</code>类封装了一个<code>mutex</code>和一个<code>ofstream</code>对象，然后<code>shared_print</code>函数在<code>mutex</code>的保护下，是线程安全的。使用的时候，先定义一个<code>LogFile</code>的实例<code>log</code>，主线程中直接使用，子线程中通过引用传递过去（也可以使用单例来实现）,这样就能保证资源被互斥锁保护着，外面没办法使用但是使用资源。</p>
<p>但是这个时候还是得小心了！用互斥元保护数据并不只是像上面那样保护每个函数，就能够完全的保证线程安全，如果将资源的指针或者引用不小心传递出来了，所有的保护都白费了！要记住一下两点：</p>
<ol>
<li><p>不要提供函数让用户获取资源。</p>
</li>
<li><p>不要资源传递给用户的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogFile</span> &#123;</span><br><span class="line">    std::mutex m_mutex;</span><br><span class="line">    ofstream f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LogFile</span>() &#123;</span><br><span class="line">        f.<span class="built_in">open</span>(<span class="string">&quot;log.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">LogFile</span>() &#123;</span><br><span class="line">        f.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shared_print</span><span class="params">(string msg, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.Never return f to the outside world</span></span><br><span class="line">    <span class="function">ofstream&amp; <span class="title">getStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f;  <span class="comment">//never do this !!!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.Never pass f as an argument to user provided function</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">void</span> fun(ostream&amp;))</span> </span>&#123;</span><br><span class="line">        <span class="built_in">fun</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上两种做法都会将资源暴露给用户，造成不必要的安全隐患。</p>
<h2 id="接口设计中也存在竞争条件"><a href="#接口设计中也存在竞争条件" class="headerlink" title="接口设计中也存在竞争条件"></a>接口设计中也存在竞争条件</h2><p><code>STL</code>中的<code>stack</code>类是线程不安全的，于是你模仿着想写一个属于自己的线程安全的类<code>Stack</code>。于是，你在<code>push</code>和<code>pop</code>等操作得时候，加了互斥锁保护数据。但是在多线程环境下使用使用你的<code>Stack</code>类的时候，却仍然有可能是线程不安全的，why？</p>
<p>假设你的<code>Stack</code>类的接口如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">//弹出栈顶元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">top</span><span class="params">()</span></span>; <span class="comment">//获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>;<span class="comment">//将元素放入栈</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data; </span><br><span class="line">    std::mutex _mu; <span class="comment">//保护内部数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类中的每一个函数都是线程安全的，但是<strong>组合起来却不是</strong>。加入栈中有<code>9,3,8,6</code>共4个元素，你想使用两个线程分别取出栈中的元素进行处理，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   Thread A                Thread B</span><br><span class="line"><span class="type">int</span> v = st.<span class="built_in">top</span>(); <span class="comment">// 6</span></span><br><span class="line">                      <span class="type">int</span> v = st.<span class="built_in">top</span>(); <span class="comment">// 6</span></span><br><span class="line">st.<span class="built_in">pop</span>(); <span class="comment">//弹出6</span></span><br><span class="line">                      st.<span class="built_in">pop</span>(); <span class="comment">//弹出8</span></span><br><span class="line">                      <span class="built_in">process</span>(v);<span class="comment">//处理6</span></span><br><span class="line"><span class="built_in">process</span>(v); <span class="comment">//处理6</span></span><br></pre></td></tr></table></figure>

<p>可以发现在这种执行顺序下， 栈顶元素被处理了两遍，而且多弹出了一个元素<code>8</code>，导致&#96;8没有被处理！这就是由于接口设计不当引起的竞争。解决办法就是将这两个接口合并为一个接口！就可以得到线程安全的栈。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">//弹出栈顶元素并返回</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>;<span class="comment">//将元素放入栈</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data; </span><br><span class="line">    std::mutex _mu; <span class="comment">//保护内部数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这样使用就不会发生问题</span></span><br><span class="line"><span class="type">int</span> v = st.<span class="built_in">pop</span>(); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">process</span>(v);</span><br></pre></td></tr></table></figure>

<p>但是注意：这样修改之后<strong>是线程安全</strong>的，但是<strong>并不是异常安全</strong>的，这也是为什么<code>STL</code>中栈的出栈操作分解成了两个步骤的原因。（为什么不是异常安全的还没想明白。。）</p>
<p>所以，为了保护共享数据，还得好好设计接口才行。</p>
<p>作者：<a target="_blank" rel="noopener" href="https://www.jianshu.com/u/a549acfa2f33">StormZhu</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hokori.cn/2019/11/30/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B(2)%E3%80%90%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hokori">
      <meta itemprop="description" content="hentai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hokori">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/30/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B(2)%E3%80%90%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%91/" class="post-title-link" itemprop="url">C++11多线程(2)【理解线程类的构造函数】</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-30 18:21:09" itemprop="dateCreated datePublished" datetime="2019-11-30T18:21:09+08:00">2019-11-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-24 11:36:52" itemprop="dateModified" datetime="2022-05-24T11:36:52+08:00">2022-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/C-11/" itemprop="url" rel="index"><span itemprop="name">C++11</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/C-11/%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="构造函数的参数"><a href="#构造函数的参数" class="headerlink" title="构造函数的参数"></a>构造函数的参数</h2><p><code>std::thread</code>类的构造函数是使用<strong>可变参数模板</strong>实现的，也就是说，可以传递任意个参数，第一个参数是线程的入口<strong>函数</strong>，而后面的若干个参数是该函数的<strong>参数</strong>。</p>
<p>第一参数的类型并不是<code>c</code>语言中的函数指针（<code>c</code>语言传递函数都是使用函数指针），在<code>c++11</code>中，增加了**可调用对象(Callable Objects)**的概念，总的来说，可调用对象可以是以下几种情况：</p>
<ul>
<li>函数指针</li>
<li>重载了<code>operator()</code>运算符的类对象，即仿函数</li>
<li><code>lambda</code>表达式（匿名函数）</li>
<li><code>std::function</code></li>
</ul>
<h4 id="函数指针示例"><a href="#函数指针示例" class="headerlink" title="函数指针示例"></a>函数指针示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数 无参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数 1个参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_2</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数 2个参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_3</span><span class="params">(<span class="type">int</span> i, std::string m)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(function_1)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(function_2, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t3</span><span class="params">(function_3, <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">t3.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>

<p>实验的时候还发现一个问题，如果将重载的函数作为线程的入口函数，会发生编译错误！编译器搞不清楚是哪个函数，如下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数 无参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数 1个参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_1</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(function_1)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line"><span class="comment">// 编译错误</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C:\Users\Administrator\Documents\untitled\main.cpp:39: </span></span><br><span class="line"><span class="comment">error: no matching function for call to &#x27;std::thread::thread(&lt;unresolved overloaded function type&gt;)&#x27;</span></span><br><span class="line"><span class="comment">     std::thread t1(function_1);</span></span><br><span class="line"><span class="comment">                              ^</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fctor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 具有一个参数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Fctor f;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(f)</span></span>;  </span><br><span class="line"><span class="comment">// std::thread t2(Fctor()); // 编译错误 </span></span><br><span class="line"><span class="function">std::thread <span class="title">t3</span><span class="params">((Fctor()))</span></span>; <span class="comment">// ok</span></span><br><span class="line">std::thread t4&#123;<span class="built_in">Fctor</span>()&#125;; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>一个仿函数类生成的对象，使用起来就像一个函数一样，比如上面的对象<code>f</code>，当使用<code>f()</code>时就调用<code>operator()</code>运算符。所以也可以让它成为线程类的第一个参数，如果这个仿函数有参数，同样的可以写在线程类的后几个参数上。</p>
<p>而<code>t2</code>之所以编译错误，是因为编译器并没有将<code>Fctor()</code>解释为一个临时对象，而是将其解释为一个函数声明，编译器认为你声明了一个函数，这个函数不接受参数，同时返回一个<code>Factor</code>对象。解决办法就是在<code>Factor()</code>外包一层小括号<code>()</code>，或者在调用<code>std::thread</code>的构造函数时使用<code>&#123;&#125;</code>，这是<code>c++11</code>中的新的同意初始化语法。</p>
<p>但是，如果重载的<code>operator()</code>运算符有参数，就不会发生上面的错误。</p>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">([](std::string m)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; <span class="string">&quot;hello &quot;</span> &lt;&lt; m &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;, <span class="string">&quot;world&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt; f1 = std::<span class="built_in">bind</span>(&amp;A::func1, &amp;a);</span><br><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt; f2 = std::<span class="built_in">bind</span>(&amp;A::func2, &amp;a, <span class="number">1</span>);</span><br><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; f3 = std::<span class="built_in">bind</span>(&amp;A::func2, &amp;a, std::placeholders::_1);</span><br><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; f4 = std::<span class="built_in">bind</span>(&amp;A::func3, &amp;a, <span class="number">1</span>, std::placeholders::_1);</span><br><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f5 = std::<span class="built_in">bind</span>(&amp;A::func3, &amp;a, std::placeholders::_1, std::placeholders::_2);</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(f1)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(f2)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t3</span><span class="params">(f3, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t4</span><span class="params">(f4, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t5</span><span class="params">(f5, <span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="传值还是引用"><a href="#传值还是引用" class="headerlink" title="传值还是引用"></a>传值还是引用</h2><p>先提出一个问题：如果线程入口函数的的参数是引用类型，在线程内部修改该变量，主线程的变量会改变吗？</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fctor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 具有一个参数 是引用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(std::string&amp; msg)</span> </span>&#123;</span><br><span class="line">        msg = <span class="string">&quot;wolrd&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Fctor f;</span><br><span class="line">    std::string m = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(f, m)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; m &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vs下： 最终是：&quot;hello&quot;</span></span><br><span class="line"><span class="comment">// g++编译器： 编译报错</span></span><br></pre></td></tr></table></figure>

<p>事实上，该代码使用<code>g++</code>编译会报错，而使用<code>vs2015</code>并不会报错，但是子线程并没有成功改变外面的变量<code>m</code>。</p>
<p>我是这么认为的：<code>std::thread</code>类，内部也有若干个变量，当使用构造函数创建对象的时候，是将参数先赋值给这些变量，所以这些变量只是个副本，然后在线程启动并调用线程入口函数时，传递的参数只是这些副本，所以内部怎么操作都是改变副本，而不影响外面的变量。<code>g++</code>可能是比较严格，这种写法可能会导致程序发生严重的错误，索性禁止了。</p>
<p>而如果可以想真正传引用，可以在调用线程类构造函数的时候，用<code>std::ref()</code>包装一下。如下面修改后的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(f, std::ref(m))</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后<code>vs</code>和<code>g++</code>都可以成功编译，而且子线程可以修改外部变量的值。</p>
<p>当然这样并不好，多个线程同时修改同一个变量，会发生数据竞争。</p>
<p>同理，构造函数的第一个参数是可调用对象，默认情况下其实传递的还是一个副本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x, <span class="type">char</span> c)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(a, <span class="number">6</span>)</span></span>; <span class="comment">// 1. 调用的是 copy_of_a()</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(std::ref(a), <span class="number">6</span>)</span></span>; <span class="comment">// 2. a()</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(A(), <span class="number">6</span>)</span></span>; <span class="comment">// 3. 调用的是 临时对象 temp_a()</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t4</span><span class="params">(&amp;A::f, a, <span class="number">8</span>, <span class="string">&#x27;w&#x27;</span>)</span></span>; <span class="comment">// 4. 调用的是 copy_of_a.f()</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t5</span><span class="params">(&amp;A::f, &amp;a, <span class="number">8</span>, <span class="string">&#x27;w&#x27;</span>)</span></span>; <span class="comment">//5.  调用的是 a.f()</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t6</span><span class="params">(std::move(a), <span class="number">6</span>)</span></span>; <span class="comment">// 6. 调用的是 a.f(), a不能够再被使用了</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">    t5.<span class="built_in">join</span>();</span><br><span class="line">    t6.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于线程<code>t1</code>来说，内部调用的线程函数其实是一个副本，所以如果在函数内部修改了类成员，并不会影响到外面的对象。只有传递引用的时候才会修改。所以在这个时候就必须想清楚，到底是传值还是传引用！</p>
<h2 id="线程对象只能移动不可复制"><a href="#线程对象只能移动不可复制" class="headerlink" title="线程对象只能移动不可复制"></a>线程对象只能移动不可复制</h2><p>线程对象之间是不能复制的，只能移动，移动的意思是，将线程的所有权在<code>std::thread</code>实例间进行转移。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_other_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>;</span><br><span class="line"><span class="comment">// std::thread t2 = t1; // 编译错误</span></span><br><span class="line">std::thread t2 = std::<span class="built_in">move</span>(t1); <span class="comment">//只能移动 t1内部已经没有线程了</span></span><br><span class="line">t1 = std::<span class="built_in">thread</span>(some_other_function); <span class="comment">// 临时对象赋值 默认就是移动操作</span></span><br><span class="line">std::thread t3;</span><br><span class="line">t3 = std::<span class="built_in">move</span>(t2); <span class="comment">// t2内部已经没有线程了</span></span><br><span class="line">t1 = std::<span class="built_in">move</span>(t3); <span class="comment">// 程序将会终止，因为t1内部已经有一个线程在管理了</span></span><br></pre></td></tr></table></figure>

<p>作者：<a target="_blank" rel="noopener" href="https://www.jianshu.com/u/a549acfa2f33">StormZhu</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hokori.cn/2019/11/29/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B(1)%E3%80%90%E5%88%9D%E8%AF%86%E7%BA%BF%E7%A8%8B%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hokori">
      <meta itemprop="description" content="hentai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hokori">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/29/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B(1)%E3%80%90%E5%88%9D%E8%AF%86%E7%BA%BF%E7%A8%8B%E3%80%91/" class="post-title-link" itemprop="url">C++11多线程(1)【初识线程】</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-29 18:21:09" itemprop="dateCreated datePublished" datetime="2019-11-29T18:21:09+08:00">2019-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-24 11:36:52" itemprop="dateModified" datetime="2022-05-24T11:36:52+08:00">2022-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/C-11/" itemprop="url" rel="index"><span itemprop="name">C++11</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/C-11/%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是并发"><a href="#什么是并发" class="headerlink" title="什么是并发"></a>什么是并发</h2><p>并发在生活中随处可见，边走路边说话，边听歌边写代码。计算机术语中的”并发”，指的是在单个系统里同时执行多个独立的活动，而不是顺序的一个接一个的执行。对于单核CPU来说，在某个时刻只可能处理一个任务，但它却不是完全执行完一个任务再执行一个下一任务，而是一直在任务间切换，每个任务完成一点就去执行下一个任务，看起来就像任务在并行发生，虽然不是严格的同时执行多个任务，但是我们仍然称之为**并发(concurrency)<strong>。真正的并发是在在多核CPU上，能够真正的同时执行多个任务，称为</strong>硬件并发(hardware concurrency)**。</p>
<p>并发并非没有代价，在单核CPU并发执行两个任务需要付出上下文切换的时间代价。如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4427263-8e5ee0329a0fe476.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1170/format/webp" alt="img" title="双核机器的并行执行与单核机器对比"></p>
<p>假设A和B两个任务都被分成10个大小相等的块，单核CPU交替的执行两个任务，每次执行其中一块，其花费的时间并不是先完成A任务再玩成B任务所花费时间的两倍，而是要更多。这是因为系统从一个任务切换到另一个任务需要执行一次<strong>上下文切换</strong>，这是需要时间的(图中的灰色块)。上下文切换需要操作系统为当前运行的任务保存CPU的状态和指令指针，算出要切换到哪个任务，并为要切换的任务重新加载处理器状态。然后将新任务的指令和数据载入到缓存中。</p>
<h2 id="并发的方式"><a href="#并发的方式" class="headerlink" title="并发的方式"></a>并发的方式</h2><h3 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a>多进程并发</h3><p>将应用程序分为多个独立的、单线程的进程，他们可以同时运行。进程内部实现原理比较复杂，这里就不多说了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4427263-57705a0a3a475e61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/395/format/webp" alt="img" title="并发运行的进程之间的通信"></p>
<p>这些独立的进程可以通过常规的<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36132127/article/details/81129690">进程间通信机制</a>进行通信，如管道、信号、消息队列、共享内存、存储映射I&#x2F;O、信号量、套接字等。</p>
<p>缺点：</p>
<ul>
<li>进程间通信较为复杂，速度相对线程间的通信更慢。</li>
<li>启动进程的开销比线程大，使用的系统资源也更多。</li>
</ul>
<p>优点：</p>
<ul>
<li>进程间通信的机制相对于线程更加安全。</li>
<li>能够很容易的将一台机器上的多进程程序部署在不同的机器上（如果通信机制选取的是套接字的话）。</li>
</ul>
<h3 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h3><p>线程很像轻量级的进程，但是一个进程中的所有线程都共享相同的地址空间，线程间的大部分数据都可以共享。线程间的通信一般都通过共享内存来实现。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4427263-36814ade375e31bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/298/format/webp" alt="img" title="并发运行的线程之间的通信"></p>
<p>优点：</p>
<ul>
<li>由于可以共享数据，多线程间的通信开销比进程小的多。</li>
<li>线程启动的比进程快，占用的资源更少。</li>
</ul>
<p>缺点：</p>
<ul>
<li>共享数据太过于灵活，为了维护正确的共享，代码写起来比较复杂。</li>
<li>无法部署在分布式系统上。</li>
</ul>
<h2 id="为什么使用并发"><a href="#为什么使用并发" class="headerlink" title="为什么使用并发"></a>为什么使用并发</h2><p>主要原因有两个：任务拆分和提高性能。</p>
<h3 id="任务拆分"><a href="#任务拆分" class="headerlink" title="任务拆分"></a>任务拆分</h3><p>在编写软件的时候，将相关的代码放在一起，将无关的代码分开，这是一个好主意，这样能够让程序更加容易理解和测试。将程序划分成不同的任务，每个线程执行一个任务或者多个任务，可以将整个程序的逻辑变得更加简单。</p>
<h3 id="提高性能"><a href="#提高性能" class="headerlink" title="提高性能"></a>提高性能</h3><p>在两种情况下，并发能够提高性能。</p>
<ol>
<li>**任务并行(task parallelism)**：将一个单个任务分成若干个部分各自并行运行，从而降低运行时间。虽然听起来很简单，但其实是一个相当复杂的过程，设想假如各个部分之间存在很多以来，一个部分的执行需要使用到另一个任务的执行结果，这个时候并不能很好的并行完成。</li>
<li>**数据并行(data parallelism)**：每个线程在不同的数据部分上执行相同的操作。</li>
</ol>
<h2 id="多线程库简介"><a href="#多线程库简介" class="headerlink" title="多线程库简介"></a>多线程库简介</h2><p><code>C++98</code>标准中并没有线程库的存在，而在<code>C++11</code>中终于提供了多线程的标准库，提供了管理线程、保护共享数据、线程间同步操作、原子操作等类。</p>
<p>多线程库对应的头文件是<code>#include </code>，类名为<code>std::thread</code>。</p>
<p>一个简单的串行程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;I&#x27;m function_1()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">function_1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个典型的单线程的单进程程序，任何程序都是一个进程，<code>main()</code>函数就是其中的主线程，单个线程都是顺序执行。</p>
<p>将上面的程序改造成多线程程序其实很简单，让<code>function_1()</code>函数在另外的线程中执行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;I&#x27;m function_1()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(function_1)</span></span>;</span><br><span class="line">    <span class="comment">// do other things</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ol>
<li>首先，构建一个<code>std::thread</code>对象<code>t1</code>，构造的时候传递了一个参数，这个参数是一个函数，这个函数就是这个线程的<strong>入口函数</strong>，函数执行完了，整个线程也就执行完了。</li>
<li>线程创建成功后，就会<strong>立即启动</strong>，并没有一个类似<code>start</code>的函数来显式的启动线程。</li>
<li>一旦线程开始运行， 就需要显式的决定是要等待它完成(join)，或者分离它让它自行运行(detach)。注意：只需要在<code>std::thread</code>对象<strong>被销毁之前</strong>做出这个决定。这个例子中，对象<code>t1</code>是栈上变量，在<code>main</code>函数执行结束后就会被销毁，所以需要在<code>main</code>函数结束之前做决定。</li>
<li>这个例子中选择了使用<code>t1.join()</code>，主线程会一直阻塞着，直到子线程完成，<code>join()</code>函数的另一个任务是回收该线程中使用的资源。</li>
</ol>
<p><strong>线程对象和对象内部管理的线程的生命周期并不一样</strong>，如果线程执行的快，可能内部的线程已经结束了，但是线程对象还活着，也有可能线程对象已经被析构了，内部的线程还在运行。</p>
<p>假设<code>t1</code>线程是一个执行的很慢的线程，主线程并不想等待子线程结束就想结束整个任务，直接删掉<code>t1.join()</code>是不行的，程序会被终止（析构<code>t1</code>的时候会调用<code>std::terminate</code>，程序会打印<code>terminate called without an active exception</code>）。</p>
<p>与之对应，我们可以调用<code>t1.detach()</code>，从而将<code>t1</code>线程放在后台运行，所有权和控制权被转交给<code>C++</code>运行时库，以确保与线程相关联的资源在线程退出后能被正确的回收。参考<code>UNIX</code>的**守护进程(daemon process)<strong>的概念，这种被分离的线程被称为</strong>守护线程(daemon threads)**。线程被分离之后，即使该线程对象被析构了，线程还是能够在后台运行，只是由于对象被析构了，主线程不能够通过对象名与这个线程进行通信。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//延时500ms 为了保证test()运行结束之后才打印</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>)); </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;I&#x27;m function_1()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(function_1)</span></span>;</span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">// t1.join();</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test() finished&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="comment">//让主线程晚于子线程结束</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>)); <span class="comment">//延时1s</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 t1.detach()时</span></span><br><span class="line"><span class="comment">// test() finished</span></span><br><span class="line"><span class="comment">// I&#x27;m function_1()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 t1.join()时</span></span><br><span class="line"><span class="comment">// I&#x27;m function_1()</span></span><br><span class="line"><span class="comment">// test() finished</span></span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ol>
<li>由于线程入口函数内部有个<code>500ms</code>的延时，所以在还没有打印的时候，<code>test()</code>已经执行完成了，<code>t1</code>已经被析构了，但是它负责的那个线程还是能够运行，这就是<code>detach()</code>的作用。</li>
<li>如果去掉<code>main</code>函数中的<code>1s</code>延时，会发现<strong>什么都没有打印</strong>，因为主线程执行的太快，整个程序已经结束了，那个后台线程被<code>C++</code>运行时库回收了。</li>
<li>如果将<code>t1.detach()</code>换成<code>t1.join()</code>，<code>test</code>函数会在<code>t1</code>线程执行结束之后，才会执行结束。</li>
</ol>
<p>一旦一个线程被分离了，就不能够再被<code>join</code>了。如果非要调用，程序就会崩溃，可以使用<code>joinable()</code>函数判断一个线程对象能否调用<code>join()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(function_1)</span></span>;</span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t1.<span class="built_in">joinable</span>())</span><br><span class="line">        t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(!t1.<span class="built_in">joinable</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者：<a target="_blank" rel="noopener" href="https://www.jianshu.com/u/a549acfa2f33">StormZhu</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hokori.cn/2019/10/19/C%E8%AF%AD%E8%A8%80%E4%B8%ADvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hokori">
      <meta itemprop="description" content="hentai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hokori">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/19/C%E8%AF%AD%E8%A8%80%E4%B8%ADvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8/" class="post-title-link" itemprop="url">C语言中volatile关键字的作用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-19 10:21:09" itemprop="dateCreated datePublished" datetime="2019-10-19T10:21:09+08:00">2019-10-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-24 11:36:52" itemprop="dateModified" datetime="2022-05-24T11:36:52+08:00">2022-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C语言中volatile关键字的作用"><a href="#C语言中volatile关键字的作用" class="headerlink" title="C语言中volatile关键字的作用"></a>C语言中volatile关键字的作用</h1><p><strong>注：本文内容来源于<a target="_blank" rel="noopener" href="https://blog.csdn.net/tigerjb/article/details/7427366">冀博</a>博文，感谢作者的整理。</strong></p>
<h2 id="volatile详解"><a href="#volatile详解" class="headerlink" title="volatile详解"></a>volatile详解</h2><p>volatile的本意是“易变的” ，因为访问寄存器要比访问内存单元快的多，所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。<br>当要求使用volatile声明变量值的时候，&#x3D;&#x3D;系统总是重新从它所在的内存读取数据&#x3D;&#x3D;，即使它前面的指令刚刚从该处读取过数据。<br>精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。<em>（简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错）</em></p>
<h2 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h2><blockquote>
<p>告诉&#x3D;&#x3D;compiler(编译器)&#x3D;&#x3D;不能做任何优化</p>
</blockquote>
<ul>
<li>比如要往某一个地址发送两条指令</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip =...; <span class="comment">//设备地址</span></span><br><span class="line">*ip = <span class="number">1</span>; <span class="comment">//第一个指令</span></span><br><span class="line">*ip = <span class="number">2</span>; <span class="comment">//第二个指令</span></span><br></pre></td></tr></table></figure>

<ul>
<li>以上程序compiler可能做优化而成：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip = ...;</span><br><span class="line">*ip = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果第一个指令丢失。如果用volatile, compiler就不允许做任何的优化，从而保证程序的原意：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> *ip = ...;</span><br><span class="line">*ip = <span class="number">1</span>;</span><br><span class="line">*ip = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>即使你要compiler做优化，它也不会把两次付值语句间化为一。它只能做其它的优化。</p>
<blockquote>
<p>用volatile定义的变量会在程序外被改变,每次都必须从内存中读取，而不能重复使用放在cache或寄存器中的备份。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">char</span> a;</span><br><span class="line">    a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!a)&#123;</span><br><span class="line">    <span class="comment">//do some things;</span></span><br><span class="line">&#125;</span><br><span class="line">doother();</span><br></pre></td></tr></table></figure>

<p>如果没有 volatiledoother()不会被执行</p>
<h2 id="使用volatile变量的几个场景"><a href="#使用volatile变量的几个场景" class="headerlink" title="使用volatile变量的几个场景"></a>使用volatile变量的几个场景</h2><blockquote>
<p>中断服务程序中修改的供其它程序检测的变量需要加volatile；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">if</span> (i) dosomething();</span><br><span class="line">     &#125;</span><br><span class="line">｝</span><br><span class="line"><span class="comment">/* Interrupt service routine. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ISR_2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">      i=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的本意是希望ISR_2中断产生时，在main函数中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远也不会被调用。如果将变量加上volatile修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）。此例中i也应该如此说明。</p>
<blockquote>
<p>多任务环境下各任务间共享的标志应该加volatile<br>存储器映射的硬件寄存器通常也要加voliate，因为每次对它的读写都可能有不同意义。</p>
</blockquote>
<ul>
<li>例如：假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  *output = (<span class="type">unsigned</span>  <span class="type">int</span> *)<span class="number">0xff800000</span>;<span class="comment">//定义一个IO端口；</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> i;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; <span class="number">10</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          *output = i;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为9，所以编译器最后给你编译编译的代码结果相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">      *output = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你对此外部设备进行初始化的过程是必须是像上面代码一样顺序的对其赋值，显然优化过程并不能达到目的。反之如果你不是对此端口反复写操作，而是反复读操作，其结果是一样的，编译器在优化后，也许你的代码对此地址的读操作只做了一次。然而从代码角度看是没有任何问题的。这时候就该使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。</p>
<ul>
<li>例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span>  <span class="type">int</span> *output=(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0xff800000</span>;<span class="comment">//定义一个I/O端口</span></span><br></pre></td></tr></table></figure>

<p>另外，以上这几种情况经常还要同时考虑数据的完整性（相互关联的几个标志读了一半被打断了重写），在1中可以通过关中断来实现，2中禁止任务调度，3中则只能依靠硬件的良好设计。</p>
<h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><ol>
<li>一个参数既可以是const还可以是volatile吗？<br><em>可以的，例如只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</em></li>
<li>一个指针可以是volatile 吗？<br><em>可以，当一个中服务子程序修该一个指向一个buffer的指针时。</em></li>
</ol>
<h2 id="volatile的本质："><a href="#volatile的本质：" class="headerlink" title="volatile的本质："></a>volatile的本质：</h2><blockquote>
<p>编译器的优化<br>在本次线程内, 当读取一个变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中；以后，再取变量值时，就直接从寄存器中取值；当变量值在本线程里改变时，会同时把变量的新值copy到该寄存器中，以便保持一致。</p>
</blockquote>
<p>当变量在因别的线程等而改变了值，该寄存器的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致。</p>
<p>当该寄存器在因别的线程等而改变了值，原变量的值不会改变，从而造成应用程序读取的值和实际的变量值不一致。</p>
<blockquote>
<p>volatile应该解释为“直接存取原始内存地址”比较合适，“易变的”这种解释简直有点误导人。</p>
</blockquote>
<h2 id="下面的函数有什么错误："><a href="#下面的函数有什么错误：" class="headerlink" title="下面的函数有什么错误："></a>下面的函数有什么错误：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr * *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    a = *ptr;</span><br><span class="line">    b = *ptr;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">square</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    a = *ptr;</span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注意：频繁地使用volatile很可能会增加代码尺寸和降低性能,因此要合理的使用volatile。</em></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">hokori</p>
  <div class="site-description" itemprop="description">hentai</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hokori</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
